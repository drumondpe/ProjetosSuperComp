Análise de Redes Sociais: encontrando a clique máxima em um grafo.
Exemplo Clique

A análise de redes sociais (ARS) é uma abordagem oriunda de áreas tais como Sociologia, Psicologia Social e Antropologia. Tal abordagem estuda as ligações relacionais (relational tie) entre atores sociais. Os atores na ARS podem ser tanto pessoas e empresas, analisadas como unidades individuais, quanto unidades sociais coletivas como, por exemplo, departamentos dentro de uma organização, agências de serviço público em uma cidade, estados-nações de um continente, dentre outras. A ARS difere fundamentalmente de outros estudos pelo fato de que sua ênfase não é nos atributos (características) dos atores, mas nas ligações entre eles.

A idéia de uma clique em um grafo é relativamente simples. No nível mais geral, uma clique é um subconjunto de uma rede no qual os atores são mais próximos entre si do que com outros membros da rede. Em termo de laços de amizade, por exemplo, não é incomum encontrar grupos humanos que formam cliques baseando-se em idade, gênero, raça, etnia, religião, ideologia, e muitas coisas coisas. Uma clique é, portanto, um conjunto de vértices em um grafo em que cada par de vértices está diretamente conectado por uma aresta.

Encontrar a clique máxima em um grafo é uma tarefa computacionalmente desafiadora devido à natureza combinatória do problema. A dificuldade computacional surge da necessidade de explorar todas as combinações possíveis de vértices para identificar a maior clique, o que se torna exponencial em relação ao número de vértices. Isso resulta em uma complexidade computacional alta, mesmo para grafos moderadamente grandes.

A importância de estudar cliques está notavelmente presente na análise de redes sociais, onde as cliques representam grupos coesos de indivíduos que compartilham interesses, amizades ou conexões em comum. A identificação de cliques ajuda a entender a estrutura de uma rede social, identificar influenciadores e grupos de afinidade, além de auxiliar na detecção de comunidades e na análise de dinâmicas sociais.

As cliques são importantes, pois além de desenvolver em seus membros comportamentos homogêneos, elas têm, por definição, grande proximidade, aumentando a velocidade das trocas. Assim, informações dirigidas a uma clique são rapidamente absorvidas pelos seus membros, que tendem a percebê-las de forma semelhante. Isso é importante, por exemplo, em estratégias de segmentação.

Portanto, a resolução eficiente do problema da clique máxima tem aplicações valiosas em áreas que vão desde a ciência da computação até a análise de dados em redes sociais.

SUA TAREFA: Encontrar a clique máxima em um grafo.
Seu programa deve receber um grafo a partir de um input de texto (abaixo você vai encontrar o código gerador do input). A partir da leitura do arquivo, você deve armazenar o grafo computacionalmente (matriz de adjacência, por exemplo). E com isso, você deverá executar três implementações:


Abordagem Exaustiva
A exaustão é uma abordagem que seleciona iterativamente os vértices para formar um clique, geralmente começando com um vértice e adicionando outros que tenham o maior número de vizinhos já na clique. Aqui está um pseudo-código simplificado para detectar cliques em um grafo usando essa abordagem. ATENÇÃO: esse pseudo-codigo não é a solução completa dessa abordagem. Você pode se inspirar nele para compreender como resolver o problema, mas é parte de sua tarefa desenvolver a solução.

Para isso gerei esse código:
BuscaExaustiva.cpp:
#include <iostream>
#include <vector>
#include <fstream>
#include <cstdlib> // Para usar exit()
#include <chrono>  // Para medir o tempo de execução

// Função para ler o grafo a partir do arquivo de entrada
std::vector<std::vector<int>> LerGrafo(const std::string& nomeArquivo, int& numVertices) {
    std::ifstream arquivo(nomeArquivo);
    int numArestas;
    arquivo >> numVertices >> numArestas;

    std::vector<std::vector<int>> grafo(numVertices, std::vector<int>(numVertices, 0));

    for (int i = 0; i < numArestas; ++i) {
        int u, v;
        arquivo >> u >> v;
        grafo[u - 1][v - 1] = 1;
        grafo[v - 1][u - 1] = 1;  // O grafo é não direcionado
    }

    arquivo.close();
    return grafo;
}

// Função para verificar se um conjunto de vértices forma uma clique
bool VerificaClique(const std::vector<std::vector<int>>& grafo, const std::vector<int>& clique) {
    for (size_t i = 0; i < clique.size(); i++) {
        for (size_t j = i + 1; j < clique.size(); j++) {
            if (grafo[clique[i]][clique[j]] == 0) {
                return false;
            }
        }
    }
    return true;
}

// Função de busca exaustiva para encontrar a maior clique
void BuscaExaustivaClique(const std::vector<std::vector<int>>& grafo, int numVertices, std::vector<int>& melhorClique, std::vector<int>& cliqueAtual, int vertice) {
    // Verifica se a clique atual é maior que a melhor clique encontrada
    if (cliqueAtual.size() > melhorClique.size() && VerificaClique(grafo, cliqueAtual)) {
        melhorClique = cliqueAtual;
    }

    // Tenta adicionar novos vértices à clique atual
    for (int i = vertice; i < numVertices; i++) {
        // Adiciona o vértice atual à clique e chama a função recursivamente
        cliqueAtual.push_back(i);
        BuscaExaustivaClique(grafo, numVertices, melhorClique, cliqueAtual, i + 1);
        cliqueAtual.pop_back(); // Remove o vértice após a chamada recursiva
    }
}

int main(int argc, char* argv[]) {
    if (argc < 2) {
        std::cerr << "Uso: " << argv[0] << " <nome do arquivo de entrada>\n";
        return 1;
    }

    int numVertices;
    std::string nomeArquivo = argv[1];

    // Início da medição do tempo
    auto inicio = std::chrono::high_resolution_clock::now();

    // Lê o grafo a partir do arquivo fornecido na linha de comando
    std::vector<std::vector<int>> grafo = LerGrafo(nomeArquivo, numVertices);

    // Encontra a clique máxima usando busca exaustiva
    std::vector<int> melhorClique;
    std::vector<int> cliqueAtual;
    BuscaExaustivaClique(grafo, numVertices, melhorClique, cliqueAtual, 0);

    // Fim da medição do tempo
    auto fim = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> duracao = fim - inicio;
    
    std::cout << "Tempo de execução: " << duracao.count() << " segundos." << std::endl;

    // Exibe a clique máxima encontrada
    std::cout << "Clique máxima encontrada: ";
    for (int v : melhorClique) {
        std::cout << (v + 1) << " "; // Ajuste para 1-based index
    }
    std::cout << std::endl;

    // Exibe o tamanho da clique máxima
    std::cout << "Tamanho da clique máxima: " << melhorClique.size() << std::endl;

    return 0;
}

Implementação com Threads OpenMP
A implementação de uma solução com OpenMP para encontrar cliques em um grafo usando a heurística gulosa envolve a paralelização das iterações do algoritmo em diferentes threads. O OpenMP simplifica a criação de threads e a coordenação entre elas.

Nessa implementação você deve apresentar o código-fonte modificado, justificar a alteração feita, e mostrar também o speed up obtido. Faça uso de gráficos e tabelas para mostrar que sua implementação em openMP valeu a pena. Observe que mesmo assim você não vai conseguir resolver exaustivamente o problema, mas o tamanho do grafo será maior, e o tempo de processamento para um mesmo tamanho deve ser preferencialmente menor.

Para isso, fiz o seguinte código:
#include <iostream>
#include <vector>
#include <fstream>
#include <cstdlib> // Para usar exit()
#include <chrono>  // Para medir o tempo de execução
#include <omp.h>   // Biblioteca OpenMP

// Função para ler o grafo a partir do arquivo de entrada
std::vector<std::vector<int>> LerGrafo(const std::string& nomeArquivo, int& numVertices) {
    std::ifstream arquivo(nomeArquivo);
    int numArestas;
    arquivo >> numVertices >> numArestas;

    std::vector<std::vector<int>> grafo(numVertices, std::vector<int>(numVertices, 0));

    for (int i = 0; i < numArestas; ++i) {
        int u, v;
        arquivo >> u >> v;
        grafo[u - 1][v - 1] = 1;
        grafo[v - 1][u - 1] = 1;
    }

    arquivo.close();
    return grafo;
}

// Função para verificar se um conjunto de vértices forma uma clique
bool VerificaClique(const std::vector<std::vector<int>>& grafo, const std::vector<int>& clique) {
    for (size_t i = 0; i < clique.size(); i++) {
        for (size_t j = i + 1; j < clique.size(); j++) {
            if (grafo[clique[i]][clique[j]] == 0) {
                return false;
            }
        }
    }
    return true;
}

// Função de busca exaustiva para encontrar a maior clique
void BuscaExaustivaClique(const std::vector<std::vector<int>>& grafo, int numVertices, 
                          std::vector<int>& melhorClique, std::vector<int>& cliqueAtual, int vertice) {
    // Verifica se a clique atual é maior que a melhor clique encontrada
    if (cliqueAtual.size() > melhorClique.size() && VerificaClique(grafo, cliqueAtual)) {
        melhorClique = cliqueAtual;
    }

    // Tenta adicionar novos vértices à clique atual
    for (int i = vertice; i < numVertices; i++) {
        // Adiciona o vértice atual à clique e chama a função recursivamente
        cliqueAtual.push_back(i);
        BuscaExaustivaClique(grafo, numVertices, melhorClique, cliqueAtual, i + 1);
        cliqueAtual.pop_back(); // Remove o vértice após a chamada recursiva
    }
}

// Função de entrada paralelizada com OpenMP
void BuscaExaustivaParalela(const std::vector<std::vector<int>>& grafo, int numVertices, std::vector<int>& melhorClique) {
    #pragma omp parallel
    {
        std::vector<int> melhorCliqueLocal;
        std::vector<int> cliqueAtual;

        #pragma omp for schedule(dynamic)
        for (int i = 0; i < numVertices; i++) {
            cliqueAtual.push_back(i);
            BuscaExaustivaClique(grafo, numVertices, melhorCliqueLocal, cliqueAtual, i + 1);
            cliqueAtual.pop_back();

            #pragma omp critical
            {
                if (melhorCliqueLocal.size() > melhorClique.size()) {
                    melhorClique = melhorCliqueLocal;
                }
            }
        }
    }
}

int main(int argc, char* argv[]) {
    if (argc < 2) {
        std::cerr << "Uso: " << argv[0] << " <nome do arquivo de entrada>\n";
        return 1;
    }

    int numVertices;
    std::string nomeArquivo = argv[1];

    auto inicio = std::chrono::high_resolution_clock::now();

    std::vector<std::vector<int>> grafo = LerGrafo(nomeArquivo, numVertices);

    std::vector<int> melhorClique;
    BuscaExaustivaParalela(grafo, numVertices, melhorClique);

    auto fim = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> duracao = fim - inicio;
    
    std::cout << "Tempo de execução: " << duracao.count() << " segundos." << std::endl;

    std::cout << "Clique máxima encontrada: ";
    for (int v : melhorClique) {
        std::cout << (v + 1) << " ";
    }
    std::cout << std::endl;

    std::cout << "Tamanho da clique máxima: " << melhorClique.size() << std::endl;

    return 0;
}

Por fim:
Paralelização e Distribuição do Processamento com MPI
Nesta implementação, você deve dividir o problema em várias partes e distribuí-las para diferentes processadores usando a biblioteca MPI (Message Passing Interface). Cada processador será responsável por encontrar cliques em uma parte do grafo, e os resultados serão combinados no final para encontrar todas as cliques no grafo. (LEMBRE QUE DEVE SER APENAS MPI, SEM OPENMP)

Já criei esse .slurm:
#!/bin/bash
#SBATCH --job-name=exercicio3
#SBATCH --output=exercicio3_output.txt
#SBATCH --error=exercicio3_error.txt
#SBATCH --ntasks=4               # Número de processos MPI
#SBATCH --cpus-per-task=1        # Cada processo MPI usará 1 CPU
#SBATCH --time=01:00:00          # Tempo limite de execução
#SBATCH --mem=2048M              # Memória alocada para a tarefa
#SBATCH --partition=espec        # Partição (ajuste conforme necessário)

# Mova para o diretório onde o job foi submetido
cd $SLURM_SUBMIT_DIR

# Executa o programa MPI usando o arquivo de entrada especificado
mpirun -np $SLURM_NTASKS ./exercicio3 grafo30.txt

Crie o BuscaExaustivaMPI.cpp